<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Windows Emu</title>
    <script src="libv86.js"></script>
    <style>
      body {
        font-family: Arial, sans-serif;
        background-color: #f0f0f0;
        margin: 0;
        padding: 0;
      }

      nav {
            background-color: #333;
            color: white;
            padding: 15px;
            text-align: center;
        }
        nav a {
            color: white;
            text-decoration: none;
            font-size: 20px;
            font-weight: bold;
            margin: 0 10px;
        }

      #gameslist {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        padding: 20px;
        gap: 20px;
      }

      .gameitem {
        background-color: white;
        border: 1px solid #ddd;
        border-radius: 10px;
        overflow: hidden;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        transition: transform 0.2s, box-shadow 0.2s;
        width: 200px;
        text-align: center;
        height: 300px;
      }

      .gameitem .gametitle {
        padding: 10px;
        font-size: 16px;
        font-weight: bold;
        color: #333;
      }

      .gameitem:hover {
        transform: translateY(-5px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
      }

      .gameitem a {
        display: block;
        text-decoration: none;
        color: inherit;
      }

      #screen_container {
        flex: 1;
        display: flex;
        justify-content: center;
        align-items: center;
        background-color: #fff;
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        height: 600px;
      }

      .centre {
        justify-content: center;
        align-items: center;
        display: flex;
      }
      .btn {
        background-color: #333;
        color: white;
        padding: 10px 20px;
        margin: 10px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        transition: background-color 0.3s;
      }

      .btn:hover {
        background-color: #888888;
      }

      .btn:disabled {
        background-color: #a5a5a5;
        cursor: not-allowed;
      }
    </style>
  </head>
  <body>
    <nav>
      <a href="/">Home</a>
      <a href="/cloud.html">Cloud Saves</a>
  </nav>
    <br>
    <center>
      <p id="loadingtxt">-</p>
      <progress id="progressBar"></progress>
      <div id=screen_container>
        <div style="white-space: pre; font: 14px monospace; line-height: 14px"></div>
        <canvas style="display: none"></canvas>
      </div>
      <p id="downloadtext">Idle</p>
      <br>
      <button class="btn" id="save">Cloud Save</button>
      <p id="whensave">Loading...</p>
      <progress style="display: none;" id="savingprog" value="0"></progress>

      <button style="display: none;" id="save_file">File Save</button>
      <button style="display: none;" id="reboot">Reboot</button>

      <script>
        const screenContainer = document.getElementById('screen_container');
        screenContainer.addEventListener('click', function() {
          lockPointer();
        });

        function lockPointer() {
          screenContainer.requestPointerLock().then(() => {
            document.documentElement.style.pointerEvents = 'none';
            document.addEventListener('pointerlockchange', pointerLockChange);
          }).catch((err) => {
            document.documentElement.style.pointerEvents = 'auto';
          });
        }

        function pointerLockChange() {
          if (document.pointerLockElement === screenContainer) {
          } else {
            document.documentElement.style.pointerEvents = 'auto';
            document.removeEventListener('pointerlockchange', pointerLockChange);
          }
        }
      </script>
    </center>
    <h1 id="gametitle" class="centre"></h1>
    <p id="gamedesc" class="centre"></p>
    <div id="gameslist"></div>
    </div>
    <script src="pako.min.js"></script>
    <script>
      function delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
      }
      (async function() {
        const gamename = decodeURIComponent(window.location.search.split("gamename=")[1])
        if (!gamename) {
          window.location.href = "/"
        }
        const r = await fetch("games.json")
        const games = await r.json()
        let content = ""
        for (const i of games) {
          if (i["name"] == gamename) {
            document.getElementById("gametitle").textContent = i["name"]
            document.getElementById("gamedesc").textContent = i["desc"]
            loadgame(i["state"], i["img"], i["name"], i["diskGB"], i["ramMB"], i["chunksizeMB"])
            continue
          }
          content += `
					<a href="/play.html?gamename=${encodeURIComponent(i["name"])}">
						<div class="gameitem">
							<img width="200" height="240" src="${i["icon"]}">
								<p class="gametitle">${i["name"]}</p>
							</div>
						</a>`
        }
        document.getElementById("gameslist").innerHTML = content
      })();
      async function fetchWithProgress(url, progressCallback) {
        const response = await fetch(url, {
          cache: "force-cache"
        });
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const contentLength = response.headers.get('Content-Length');
        if (!contentLength) throw new Error('Content-Length response header unavailable');
        const total = parseInt(contentLength, 10);
        let loaded = 0;
        const reader = response.body.getReader();
        const stream = new ReadableStream({
          start(controller) {
            function read() {
              reader.read().then(({
                done,
                value
              }) => {
                if (done) {
                  controller.close();
                  return;
                }
                loaded += value.byteLength;
                progressCallback(loaded, total);
                controller.enqueue(value);
                read();
              }).catch(error => {
                console.error(error);
                controller.error(error);
              });
            }
            read();
          }
        });
        return new Response(stream);
      }
      async function loadgame(stateurl, drive, gamename, disk, ram, chunksize) {
        const loadingtext = document.getElementById("loadingtxt")
        const progressBar = document.getElementById("progressBar")
        const progressCallback = (loaded, total) => {
          loadingtext.textContent = `Loading ${gamename} [${((loaded / total) * 100).toFixed(2)}%]`;
          progressBar.value = (loaded / total)
        };

        const lastsave = document.getElementById("whensave")
        const savingprogress = document.getElementById("savingprog")

        let statres;

        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        async function loaddata() {
          
          let cloudstorage = localStorage.getItem("cloud")
          let saveexist = false
          let savedtime;
          if (cloudstorage) {
            const r = await fetch(`https://${cloudstorage}.glitch.me/saved?gamename=${gamename}`);
            const a = await r.text()
            if (a != "Not Saved") {
              saveexist = true
              savedtime = a
            }
          }

          if (!saveexist) {
            lastsave.textContent = "Downloading Game..."
            const stater = await fetchWithProgress(stateurl, progressCallback)
            statres = await stater.blob()
            lastsave.textContent = "Not saved!"
          } else {
            lastsave.textContent = "Downloading Save..."
            const stater = await fetchWithProgress(`https://corsproxy.io/?https://${cloudstorage}.glitch.me/load?gamename=${gamename}&nocachefix=${generateUUID()}`, progressCallback)
            arraycomped = await stater.arrayBuffer()
            const inflatedData = pako.inflate(arraycomped);
            statres = new Blob([inflatedData], { type: 'application/octet-stream' });

            lastsave.textContent = "Saved on " + savedtime
          }

          
        }
        await loaddata()

        function getCurrentDateTimeString() {
            const now = new Date();

            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0'); // Months are zero-based
            const day = String(now.getDate()).padStart(2, '0');

            let hours = now.getHours();
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            const meridiem = hours >= 12 ? 'PM' : 'AM';
            hours = hours % 12 || 12;

            return `${year}-${month}-${day} ${hours}:${minutes}:${seconds} ${meridiem}`;
        }

        console.log(drive)

        loadingtext.remove()
        progressBar.remove()
        window.chunksize = chunksize

        let clientlastsave = 0

        let saving = false

        async function savegame() {
          const cloudstorage = localStorage.getItem("cloud")
          if (!cloudstorage) {
            lastsave.innerHTML = `Please visit <a href="/cloud.html" target="_blank">SETUP CLOUD SAVES</a> to fix`
            return
          }
          if (saving) {
            return
          }
          saving = true
          lastsave.innerHTML = "Compressing..."
          savingprogress.value = "0"
          savingprogress.style.display = ""
          await delay(100)
          const new_state = await emulator.save_state();
          const compressedData = pako.deflate(new_state).buffer;
          
          const xhr = new XMLHttpRequest();
          xhr.open('POST', `https://${cloudstorage}.glitch.me/savegame?gamename=${gamename}&currenttime=${getCurrentDateTimeString()}`, true);
          const blob = new Blob([compressedData], { type: 'application/octet-stream' });
          console.log(blob)
          let formData = new FormData();
          formData.append('file', blob, 'state.bin');

          xhr.upload.addEventListener('progress', function(event) {
              if (event.lengthComputable) {
                  lastsave.innerHTML = "Saving... " + ((event.loaded / event.total) * 100).toFixed(2) + "%"
                  savingprogress.value = (event.loaded / event.total)
              }
          });


          xhr.onreadystatechange = async function() {
              if (xhr.readyState === XMLHttpRequest.DONE) {
                  savingprogress.style.display = ""
                  savingprogress.value = "0"

                  const as = await fetch(`https://${cloudstorage}.glitch.me/saved?gamename=${gamename}`)
                  const savetime = await as.text()

                  lastsave.innerHTML = "Saved!"
                  await delay(1000)
                  lastsave.innerHTML = "Saved on " + savetime

                  clientlastsave = (new Date() + 5000)
                  saving = false
              }
          };
          
          
          xhr.send(formData);
        }

        document.getElementById("save").addEventListener("click", async function() {
          await savegame()
        });

        window.addEventListener("beforeunload", async function(event) {
            if (new Date() > clientlastsave) {
              event.preventDefault(); //hasnt saved in last 5 seconds
            }
        });


        const emulator = new V86({
          wasm_path: "/v86.wasm",
          bios: {
            url: "/seabios.bin"
          },
          vga_bios: {
            url: "/vgabios.bin"
          },
          hda: {
            url: drive,
            size: disk * 1024 * 1024 * 1024,
            async: true
          },
          memory_size: ram * 1024 * 1024,
          screen_container: screen_container,
          autostart: false,
        });
        var filereader = new FileReader();
        filereader.onload = async function(e) {
          while (true) {
            try {
              await emulator.restore_state(e.target.result);
              emulator.run();
              break
            } catch(err) {
              console.log("retrying!")
              await delay(100)
            }
          }


        };
        await filereader.readAsArrayBuffer(statres);


        //below is for developer to edit existing games quickly

        if (window.location.hostname == "localhost") {
          console.log("dev mode on!")
          document.getElementById("reboot").style.display = ""
          document.getElementById("save_file").style.display = ""
          document.getElementById("save_file").onclick = async function()
            {
                const new_state = await emulator.save_state();
                var a = document.createElement("a");
                a.download = "v86state.bin";
                a.href = window.URL.createObjectURL(new Blob([new_state]));
                a.dataset.downloadurl = "application/octet-stream:" + a.download + ":" + a.href;
                a.click();

                this.blur();
            };

            document.getElementById("reboot").onclick = async function()
            {
                await emulator.restart();
                this.blur();
            };


          
        }

      }




    </script>
  </body>
</html>